---
layout: page
title: "Autonomous Electric Wheelchair for Children with Physical Challenges"
image: "/images/wheelchair.png"
description: "Implemented mapping and autonomous driving on an electric wheelchair."
location: "Ontario Tech University, Canada"
type: "Mitacs Global Research Internship"
Date: "May 2023 - Aug 2023"
prof: "Prof. Scott Nokleby"
attachments:
  - link: "/attachments/Internship_Report.pdf"
    text: "Read Report"
---
![{{page.title}}]({{page.image}})
**Aim:** 

Develop a proof-of-concept autonomous electric wheelchair for indoor navigation. The system should be capable of avoiding both static and dynamic obstacles.

**Summary:**

We structured the codebase using *ROS*, serving as the interface between software and hardware. The wheelchair was modeled as a differential-drive system and its odometry was calculated from wheel encoder readings. To improve odometry accuracy, we fused IMU sensor data with encoder measurements using an *Unscented Kalman Filter (UKF)*.

To map the environment, we employed the Gmapping algorithm to generate a 2D occupancy map. Autonomous navigation was implemented using the *Rapidly-exploring Random Trees (RRT)* algorithm, while localization was managed by the *Adaptive Monte Carlo Localizer (AMCL)*. The robot avoided dynamic obstacles by modifying the target velocity generated by the RRT algorithm, steering it towards directions with fewer obstacles. Additionally, we generated a 3D point cloud map with the intent to detect stairways, though this feature was not fully implemented.

**Takeaways:**

This was my first experience using ROS for code management and my first autonomous robotics project, making for a steep learning curve. Despite the challenges, we successfully got the system operational. One major issue we faced was faulty sensor data from the encoders. After a week of hardware debugging, we discovered that the motor controller was malfunctioning. 

**Attachments:**

<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>

<div class="pdf-thumbnail-container">
  {% for attachment in page.attachments %}
    <a href="{{ attachment.link }}" target="_blank">
    <div class="pdf-thumbnail-wrapper">
      <canvas class="pdf-thumbnail" data-url="{{ attachment.link }}"></canvas>
      {{ attachment.text }}
    </div>
    </a>
  {% endfor %}
</div>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    document.querySelectorAll(".pdf-thumbnail").forEach((canvas) => {
      const url = canvas.getAttribute("data-url");

      pdfjsLib.getDocument(url).promise.then(pdf => {
        return pdf.getPage(1);
      }).then(page => {
        const desiredWidth = 200; // Adjust this to control thumbnail width
        const viewport = page.getViewport({ scale: 1 }); // Default scale (1) to get original width

        const scale = desiredWidth / viewport.width; // Calculate scale based on desired width
        const scaledViewport = page.getViewport({ scale });

        const context = canvas.getContext("2d");

        // Set canvas size to match the scaled page
        canvas.width = scaledViewport.width;
        canvas.height = scaledViewport.height;

        const renderContext = {
          canvasContext: context,
          viewport: scaledViewport
        };

        return page.render(renderContext).promise;
      });

      canvas.addEventListener("click", () => {
        window.open(url, "_blank");
      });
    });
  });
</script>
